/*
Michael Lazear, (C) 2007-2016

kernel.c
*/

#include <kernel.h>
#include <vga.h>
#include <x86.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <types.h>
#include <mutex.h>

char logo[] = {0x5f,0x5f,0x5f,0x2e,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x5f,0x5f,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x2e,0x5f,0x5f,0x20,0x20,0x20,0x0a,0x5c,0x5f,0x20,0x7c,0x5f,0x5f,0x20,0x5f,0x5f,0x5f,0x5f,0x5f,0x20,0x5f,0x5f,0x5f,0x5f,0x5f,0x5f,0x5f,0x20,0x20,0x20,0x5f,0x5f,0x5f,0x5f,0x20,0x20,0x20,0x5f,0x5f,0x5f,0x5f,0x5f,0x20,0x20,0x20,0x5f,0x5f,0x5f,0x5f,0x5f,0x2f,0x20,0x20,0x7c,0x5f,0x5f,0x5f,0x5f,0x5f,0x5f,0x20,0x20,0x7c,0x20,0x20,0x7c,0x20,0x20,0x0a,0x20,0x7c,0x20,0x5f,0x5f,0x20,0x5c,0x5c,0x5f,0x5f,0x20,0x20,0x5c,0x5c,0x5f,0x20,0x20,0x5f,0x5f,0x20,0x5c,0x5f,0x2f,0x20,0x5f,0x5f,0x20,0x5c,0x20,0x2f,0x20,0x20,0x20,0x20,0x20,0x5c,0x5f,0x2f,0x20,0x5f,0x5f,0x20,0x5c,0x20,0x20,0x20,0x5f,0x5f,0x5c,0x5f,0x5f,0x20,0x20,0x5c,0x20,0x7c,0x20,0x20,0x7c,0x20,0x20,0x0a,0x20,0x7c,0x20,0x5c,0x5f,0x5c,0x20,0x5c,0x2f,0x20,0x5f,0x5f,0x20,0x5c,0x7c,0x20,0x20,0x7c,0x20,0x5c,0x2f,0x5c,0x20,0x20,0x5f,0x5f,0x5f,0x2f,0x7c,0x20,0x20,0x59,0x20,0x59,0x20,0x20,0x5c,0x20,0x20,0x5f,0x5f,0x5f,0x2f,0x7c,0x20,0x20,0x7c,0x20,0x20,0x2f,0x20,0x5f,0x5f,0x20,0x5c,0x7c,0x20,0x20,0x7c,0x5f,0x5f,0x0a,0x20,0x7c,0x5f,0x5f,0x5f,0x20,0x20,0x28,0x5f,0x5f,0x5f,0x5f,0x20,0x20,0x2f,0x5f,0x5f,0x7c,0x20,0x20,0x20,0x20,0x5c,0x5f,0x5f,0x5f,0x20,0x20,0x3e,0x5f,0x5f,0x7c,0x5f,0x7c,0x20,0x20,0x2f,0x5c,0x5f,0x5f,0x5f,0x20,0x20,0x3e,0x5f,0x5f,0x7c,0x20,0x28,0x5f,0x5f,0x5f,0x5f,0x20,0x20,0x2f,0x5f,0x5f,0x5f,0x5f,0x2f,0x0a,0x20,0x20,0x20,0x20,0x20,0x5c,0x2f,0x20,0x20,0x20,0x20,0x20,0x5c,0x2f,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x5c,0x2f,0x20,0x20,0x20,0x20,0x20,0x20,0x5c,0x2f,0x20,0x20,0x20,0x20,0x20,0x5c,0x2f,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x5c,0x2f,0x20,0x20,0x20,0x20,0x20, '\n'};

static mutex key_mutex = { .lock = 0 };

extern STREAM* kb;

void event_loop() {
	while(1) {

		acquire(&key_mutex);
		if (ftell(kb)) {
			fflush(kb);
			list_procs();

		}
		release(&key_mutex);

		yield();
	}
}

extern uint32_t* MM_CURRENT_PT;
extern uint32_t* MM_CURRENT_PD;

void memtr1() {
	int i = 1;
	int t = 0;
	vga_pretty("Beginning physical memory test!\n", VGA_LIGHTGREEN);
	vga_kputs("PT", 0, 22);
	vga_kputs("PD", 0, 23);
	vga_kputs("Phys addr", 0, 24);
	vga_kputs("Cycles/tick", 110, 24);
	while(1) {
		void* ptr = k_page_alloc();
		if (!ptr) {
			//traverse_blockchain();

			die();
		}
		void *buf = malloc(32);
		ftoa((double)i/t, buf);
		vga_kputs(buf, 140, 24);


		memset(buf, 0, 32);
		itoa(ptr, buf, 16);
		vga_kputs(buf, 20, 24);
		
		int _pti = mm_first_free(MM_CURRENT_PT)/32;
		int _pdi = mm_first_free(MM_CURRENT_PD)/32;
		uint32_t ptidx = MM_CURRENT_PT[_pti];
		uint32_t pdidx = MM_CURRENT_PD[_pdi];

		memset(buf, 0, 32);
		itoa(pdidx, buf, 2);
		vga_kputs(buf, 20, 23);

		memset(buf, 0, 32);
		itoa(_pdi%32, buf, 10);
		vga_kputs(buf, 10, 23);

		memset(buf, 0, 32);
		itoa(ptidx, buf, 2);
		vga_kputs(buf, 20, 22);

		memset(buf, 0, 32);
		itoa(_pti%32, buf, 10);
		vga_kputs(buf, 10, 22);

		free(buf);
		//printf("%x -- %d %d (Cycles per tick: %e)\n", ptr, i, t, ((double)i/ t));
		free(ptr);
		t = get_ticks();
		i++;
		//wait(5);
		yield();


	}
}


void fn3() {
	asm volatile("int $0x80");
	for(;;);
}

extern void switch_to_user(void* (fn)(), uint32_t esp);
//We enter into kernel initialize with the GDT and IDT already loaded, and interrupts disabled
void kernel_initialize(uint32_t kernel_end) {

	/*
	1.	Initialize physical memory manager, with private heap @ kernel_end to 2MB
			- Bitmap has the first 2MB (512 bits) marked as used, will not be allocated
			- Allows k_page_alloc()
	2.	Initialize paging, passing the reserved first page directory address
	3.	Initialize heap management with malloc, free, and sbrk.
			- Utilizes both k_page_alloc() and k_paging_map() to generate a continous
				virtual address space.
			- Public heap starts at 3GB. This should be changed when higher half is implemented
	4.	Todo - initialize multithreading.
	*/
	uint32_t* pagedir = k_mm_init(kernel_end);
	k_paging_init(pagedir);
	k_heap_init();
	// Start timer
	//tss_flush();
	keyboard_install();
	timer_init();
	syscall_init();
	// Initial start interrupts.
	sti();

	vga_setcolor(VGA_COLOR(VGA_WHITE, VGA_BLACK));
	vga_clear();
	vga_pretty(logo, VGA_CYAN);



	sched_init();
	//acquire(&key_mutex);
	printf("Back in kernel-init\n");

/*	while(1) {

		list_procs();
		wait(5);
		//yield();
	}*/
	spawn("memtest", memtr1);
	spawn("event", event_loop);
	while(1) {
		yield();
		//wait(5);
	}


	for(;;);
}

